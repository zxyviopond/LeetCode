{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf320
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red127\green0\blue85;\red63\green127\blue95;\red0\green0\blue192;
\red42\green0\blue255;}
\margl1440\margr1440\vieww15200\viewh11360\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs22 \cf2 public\cf0  \cf2 static\cf0  TreeNode buildTree(\cf2 int\cf0 [] inorder, \cf2 int\cf0 [] postorder) \{\
		\cf3 //Construct all \ul Standalone\ulnone  TreeNode\cf0 \
		TreeNode[] allnode = \cf2 new\cf0  TreeNode[inorder.\cf4 length\cf0 ];\
		\cf2 for\cf0 (\cf2 int\cf0  i=0;i<allnode.\cf4 length\cf0 ;i++)\{\
			allnode[i]=\cf2 new\cf0  TreeNode(inorder[i]);\
		\}\
		TreeNode result=recurbuildTree(inorder,postorder,allnode);\
		\
		\cf2 return\cf0  result;\
	\}\
	\
	\cf2 public\cf0  \cf2 static\cf0  TreeNode recurbuildTree(\cf2 int\cf0 [] inorder,\cf2 int\cf0 [] postorder,TreeNode[] allnode)\{\
		\cf2 if\cf0 (postorder.\cf4 length\cf0 ==0) \cf2 return\cf0  \cf2 null\cf0 ;\
		TreeNode root = getNodebyValue(postorder[postorder.\cf4 length\cf0 -1],allnode);\
	    \cf2 int\cf0 [] new_inorderleft = splitleft(root.\cf4 val\cf0 ,inorder);\
	    \cf2 int\cf0 [] new_postorderleft=getpostleft(new_inorderleft,postorder);\
	    TreeNode leftchild = recurbuildTree(new_inorderleft,new_postorderleft,allnode);\
	    \cf2 int\cf0 [] new_inorderright= splitright(root.\cf4 val\cf0 ,inorder);\
	    \cf2 int\cf0 [] new_postorderright=getpostright(new_inorderright,postorder);\
	    TreeNode rightchild = recurbuildTree(new_inorderright,new_postorderright,allnode);\
	    root.\cf4 left\cf0 =leftchild;\
	    root.\cf4 right\cf0 =rightchild;\
	    \cf2 return\cf0  root;\
	\}\
	\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 int\cf0 [] getpostright(\cf2 int\cf0 [] new_inorderright, \cf2 int\cf0 [] postorder) \{\
		\cf2 int\cf0 [] result= \cf2 new\cf0  \cf2 int\cf0 [new_inorderright.\cf4 length\cf0 ];\
		\cf2 for\cf0 (\cf2 int\cf0  i=0;i<result.\cf4 length\cf0 ;i++)\{\
			result[i]=postorder[postorder.\cf4 length\cf0 -result.\cf4 length\cf0 -1+i];\
		\}\
		\cf2 return\cf0  result;\
	\}\
\
\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 int\cf0 [] getpostleft(\cf2 int\cf0 [] new_inorderleft, \cf2 int\cf0 [] postorder) \{\
		\cf2 int\cf0 [] result = \cf2 new\cf0  \cf2 int\cf0 [new_inorderleft.\cf4 length\cf0 ];\
		\cf2 for\cf0 (\cf2 int\cf0  i=0;i<result.\cf4 length\cf0 ;i++)\{\
			result[i]=postorder[i];\
		\}\
		\cf2 return\cf0  result;\
	\}\
\
\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 int\cf0 [] splitleft(\cf2 int\cf0  val, \cf2 int\cf0 [] inorder) \{\
		\cf2 int\cf0  i;\
		\cf2 for\cf0 (i=0;i<inorder.\cf4 length\cf0 ;i++)\{\
			\cf2 if\cf0 (inorder[i]==val) \cf2 break\cf0 ;\
		\}\
		\cf2 int\cf0 [] result = \cf2 new\cf0  \cf2 int\cf0 [i];\
		\cf2 for\cf0 (\cf2 int\cf0  j=0;j<i;j++)\{\
			result[j]=inorder[j];\
		\}\
		\
		\cf2 return\cf0  result;\
	\}\
	\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 int\cf0 [] splitright(\cf2 int\cf0  val, \cf2 int\cf0 [] inorder) \{\
		\cf2 int\cf0  i;\
		\cf2 for\cf0 (i=0;i<inorder.\cf4 length\cf0 ;i++)\{\
			\cf2 if\cf0 (inorder[i]==val) \cf2 break\cf0 ;\
		\}\
		\cf2 int\cf0 [] result = \cf2 new\cf0  \cf2 int\cf0 [inorder.\cf4 length\cf0 -i-1];\
		\cf2 for\cf0 (\cf2 int\cf0  j=0;j<result.\cf4 length\cf0 ;j++)\{\
			result[j]=inorder[i+1+j];\
		\}\
		\
		\cf2 return\cf0  result;\
	\}\
	\
\
\
	\cf2 public\cf0  \cf2 static\cf0  TreeNode getNodebyValue(\cf2 int\cf0  value,TreeNode[] allnode)\{\
		TreeNode result=\cf2 null\cf0 ;\
		\cf2 for\cf0 (\cf2 int\cf0  i=0;i<allnode.\cf4 length\cf0 ;i++)\{\
			\cf2 if\cf0 (allnode[i].\cf4 val\cf0  == value)\{\
				result = allnode[i];\
				\cf2 break\cf0 ;\
			\}\
		\}\
		\cf2 return\cf0  result;\
	\}\
\
\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 void\cf0  InOrder(TreeNode resultroot) \{\
		\cf2 if\cf0 (resultroot==\cf2 null\cf0 ) \cf2 return\cf0 ;\
		InOrder(resultroot.\cf4 left\cf0 );\
		System.\cf4 out\cf0 .print(resultroot.\cf4 val\cf0 +\cf5 ","\cf0 );\
		InOrder(resultroot.\cf4 right\cf0 );\
	\}\
	\
	\cf2 private\cf0  \cf2 static\cf0  \cf2 void\cf0  PostOrder(TreeNode resultroot) \{\
		\cf2 if\cf0 (resultroot==\cf2 null\cf0 ) \cf2 return\cf0 ;\
		PostOrder(resultroot.\cf4 left\cf0 );\
		PostOrder(resultroot.\cf4 right\cf0 );\
		System.\cf4 out\cf0 .print(resultroot.\cf4 val\cf0 +\cf5 ","\cf0 );\
	\}\
}